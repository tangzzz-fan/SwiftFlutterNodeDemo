# 性能优化方案

## 1. 优化目标与指标

### 1.1 性能指标定义

| 指标项 | 当前值 | 目标值 | 说明 |
|--------|--------|--------|------|
| 首屏加载时间 | ~2000ms | < 300ms | 从打开到内容可见 |
| 白屏时间 | ~1500ms | < 100ms | 骨架屏优化 |
| WebView初始化 | ~800ms | < 50ms | 使用WebView池 |
| 资源加载完成 | ~1200ms | < 500ms | 预加载优化 |
| 页面可交互时间 | ~2500ms | < 800ms | JS执行优化 |
| 内存占用 | ~200MB | < 150MB | 资源优化 |

### 1.2 优化策略概览

```
┌─────────────────────────────────────────────────────────┐
│              性能优化三层架构                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Layer 1: 预加载层（减少等待时间）                       │
│  ┌────────────────────────────────────────────┐        │
│  │ • WebView池预创建                          │        │
│  │ • 资源包预下载                              │        │
│  │ • 离线包准备                                │        │
│  └────────────────────────────────────────────┘        │
│                                                         │
│  Layer 2: 感知优化层（改善用户体验）                     │
│  ┌────────────────────────────────────────────┐        │
│  │ • 骨架屏展示                                │        │
│  │ • 渐进式渲染                                │        │
│  │ • 过渡动画                                  │        │
│  └────────────────────────────────────────────┘        │
│                                                         │
│  Layer 3: 实际加载层（提升真实性能）                     │
│  ┌────────────────────────────────────────────┐        │
│  │ • 资源压缩与CDN                             │        │
│  │ • 代码分割与懒加载                          │        │
│  │ • 缓存策略                                  │        │
│  └────────────────────────────────────────────┘        │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

## 2. 骨架屏方案

### 2.1 骨架屏原理

```
时间轴:
┌──────────────────────────────────────────────────────┐
│                                                      │
│  0ms        100ms       500ms      1000ms   1500ms  │
│   │          │           │           │         │    │
│   ├─ 显示骨架屏                                      │
│   │          │                                      │
│   │          ├─ WebView开始加载                     │
│   │          │           │                          │
│   │          │           ├─ HTML解析完成            │
│   │          │           │           │              │
│   │          │           │           ├─ 首屏渲染    │
│   │          │           │           │         │    │
│   │          │           │           │         ├─ JS执行完成
│   │          │           │           │         │    │
│   └──────────┴───────────┴───────────┴─────────┴─ 隐藏骨架屏
│                                                      │
│   [Flutter层骨架屏]      [WebView真实内容]          │
│                                                      │
└──────────────────────────────────────────────────────┘
```

### 2.2 实现方式

#### 方式1: Flutter Widget骨架屏（推荐）

**优点**:
- 纯原生渲染，性能最好
- 可复用Flutter组件
- 易于维护和定制

**实现要点**:
```
MallWebViewScreen
├── Stack
    ├── WebViewWidget (底层)
    └── SkeletonWidget (顶层，根据加载状态显示/隐藏)
        ├── ShimmerEffect (闪烁动画)
        ├── ProductCardSkeleton × N
        └── BannerSkeleton
```

#### 方式2: HTML骨架屏注入

**优点**:
- 可以完全模拟真实布局
- 支持服务端渲染

**实现流程**:
```
1. 准备骨架屏HTML
   ↓
2. WebView loadRequest前，先加载骨架屏HTML
   ↓
3. 通过JS注入，在真实内容加载完成后替换
   ↓
4. 使用CSS transition实现平滑过渡
```

### 2.3 骨架屏设计原则

1. **布局相似性**: 骨架屏布局应与真实内容高度一致
2. **动画引导**: 使用shimmer动画给用户"正在加载"的反馈
3. **及时隐藏**: 在首屏内容可见时立即隐藏骨架屏
4. **性能优先**: 骨架屏本身不能影响性能

## 3. WebView池预加载方案

### 3.1 WebView池原理

```
应用启动
    ↓
初始化WebView池（预创建3个WebView）
    ↓
┌───────────────────────────────────────┐
│        WebView Pool Manager           │
├───────────────────────────────────────┤
│  空闲池 (Idle Pool)                   │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐│
│  │WebView1│  │WebView2│  │WebView3││
│  │(ready) │  │(ready) │  │(ready) ││
│  └─────────┘  └─────────┘  └─────────┘│
│                                       │
│  使用中 (Active)                      │
│  ┌─────────┐                          │
│  │WebView4│ ← 用户正在浏览            │
│  └─────────┘                          │
│                                       │
│  回收队列 (Recycle)                   │
│  ┌─────────┐                          │
│  │WebView5│ ← 待清理重置              │
│  └─────────┘                          │
└───────────────────────────────────────┘
```

### 3.2 生命周期管理

```
WebView生命周期:

创建 → 预热 → 空闲 → 分配 → 使用中 → 回收 → 重置 → 空闲
  ↑                                              ↓
  └──────────────── 或销毁 ←─────────────────────┘
```

**关键策略**:

1. **预创建时机**: 
   - 应用启动时创建1个
   - 首页加载完成后补充到3个
   - 避免启动阶段性能影响

2. **预加载内容**:
   - 加载空白页或骨架屏HTML
   - 注入JSBridge代码
   - 设置通用配置（User-Agent、Cookie等）

3. **分配策略**:
   - 先进先出（FIFO）
   - 优先分配预热完成的WebView
   - 池空时同步创建新WebView

4. **回收策略**:
   - 页面关闭后清理数据
   - 重置WebView状态
   - 重新加载空白页
   - 放回空闲池

### 3.3 内存管理

**容量控制**:
```
最小池大小: 1个 (保证秒开)
最大池大小: 3个 (平衡性能与内存)
活跃上限: 5个 (超过则开始回收)
```

**内存优化**:
- 监听系统内存警告
- 低内存时清空空闲池
- 定期检查并释放长时间未使用的WebView

## 4. 资源预加载方案

### 4.1 预加载时机

```
应用生命周期          预加载策略
─────────────────────────────────────
App启动
  ↓
首页展示              
  ↓                   ↓
用户浏览          检查商城资源版本
  ↓                   ↓
                  WiFi环境 → 后台下载新版本
  ↓                   ↓
                  下载完成 → 后台校验&解压
  ↓                   ↓
用户点击商城        ↓
  ↓                   ↓
加载本地最新版本 ← 预加载完成
```

### 4.2 预加载策略

| 策略 | 触发条件 | 优先级 | 说明 |
|------|---------|--------|------|
| 应用启动预加载 | App冷启动 | 低 | 不阻塞主流程 |
| 空闲预加载 | 用户无操作3s | 中 | 利用空闲时间 |
| WiFi预加载 | 检测到WiFi | 高 | 更新大版本 |
| 智能预测 | 用户行为分析 | 中 | 预测即将访问的页面 |

### 4.3 预加载内容

**关键资源**:
- HTML入口文件
- 首屏CSS
- 首屏JS（main bundle）
- 首屏图片（banner、icon）

**延迟资源**:
- 非首屏组件
- 懒加载模块
- 低优先级图片

## 5. 秒开优化综合方案

### 5.1 秒开核心路径

```
点击商城入口
    ↓
从WebView池获取预热的WebView (50ms)
    ↓
显示Flutter骨架屏 (立即)
    ↓
加载本地离线包 (100ms)
    ↓
渲染首屏内容 (150ms)
    ↓
隐藏骨架屏，显示真实内容 (总计 300ms)
    ↓
后台请求接口更新数据
    ↓
局部刷新页面
```

### 5.2 优化组合拳

```
┌──────────────────────────────────────────┐
│         秒开优化技术栈                    │
├──────────────────────────────────────────┤
│                                          │
│  基础设施层:                              │
│  • 离线包机制 (减少网络请求)              │
│  • CDN加速 (加快资源下载)                 │
│  • HTTP/2 (多路复用)                      │
│                                          │
│  容器层:                                  │
│  • WebView池 (消除初始化时间)             │
│  • 预加载 (提前准备资源)                  │
│  • 进程复用 (避免冷启动)                  │
│                                          │
│  渲染层:                                  │
│  • 骨架屏 (优化感知)                      │
│  • 首屏直出 (SSR)                         │
│  • 渐进式渲染 (分步展示)                  │
│                                          │
│  代码层:                                  │
│  • 代码分割 (减少主包大小)                │
│  • Tree Shaking (移除无用代码)            │
│  • 懒加载 (按需加载)                      │
│                                          │
└──────────────────────────────────────────┘
```

## 6. 缓存策略

### 6.1 多级缓存架构

```
┌─────────────────────────────────────────┐
│  请求资源                                │
└─────────────┬───────────────────────────┘
              ↓
      ┌───────────────┐
      │ 内存缓存      │ ← 最快 (Flutter Map)
      │ (Memory)      │
      └───────┬───────┘
              │ Miss
              ↓
      ┌───────────────┐
      │ 磁盘缓存      │ ← 较快 (本地文件)
      │ (Disk)        │
      └───────┬───────┘
              │ Miss
              ↓
      ┌───────────────┐
      │ CDN缓存       │ ← 中等 (边缘节点)
      │ (CDN)         │
      └───────┬───────┘
              │ Miss
              ↓
      ┌───────────────┐
      │ 源站          │ ← 最慢 (服务器)
      │ (Origin)      │
      └───────────────┘
```

### 6.2 缓存策略配置

| 资源类型 | 缓存位置 | 过期时间 | 更新策略 |
|---------|---------|----------|---------|
| HTML | 磁盘 | 30分钟 | 协商缓存 |
| CSS/JS | 磁盘 | 7天 | 文件哈希版本 |
| 图片 | 磁盘 | 30天 | URL版本号 |
| API数据 | 内存 | 5分钟 | 主动失效 |
| 离线包 | 磁盘 | 永久 | 版本号控制 |

### 6.3 缓存失效策略

1. **时间失效**: 超过TTL自动失效
2. **版本失效**: 新版本发布后主动清除
3. **容量失效**: LRU算法淘汰最久未用
4. **手动失效**: 用户主动清除缓存

## 7. H5端性能优化

### 7.1 资源优化

**图片优化**:
- 使用WebP格式（体积减少30%）
- 图片懒加载（首屏外的图片延迟加载）
- 响应式图片（根据屏幕尺寸加载合适大小）
- 雪碧图合并（减少请求数）

**代码优化**:
- Gzip压缩（减少70%传输体积）
- 代码分割（按路由拆分）
- Tree Shaking（移除未使用代码）
- 压缩混淆（UglifyJS）

### 7.2 渲染优化

**首屏优化**:
- 关键CSS内联（避免阻塞）
- 非关键CSS异步加载
- 首屏数据预取
- 骨架屏占位

**运行时优化**:
- 虚拟列表（长列表渲染）
- 防抖节流（减少计算）
- RequestAnimationFrame（动画优化）
- Web Worker（后台计算）

### 7.3 打包优化

**Vite配置示例（原理说明）**:

关键优化点：
- **代码分割**: 按路由自动分割chunk
- **依赖预构建**: 第三方库预打包
- **资源内联**: 小于4KB的资源base64内联
- **Tree Shaking**: 自动移除未使用代码
- **压缩**: 生产环境自动压缩混淆

## 8. 监控与度量

### 8.1 性能指标采集

**关键时间节点**:
```
T0: 用户点击
T1: WebView获取完成
T2: HTML开始加载
T3: HTML解析完成
T4: DOMContentLoaded
T5: 首屏渲染完成
T6: onLoad完成
T7: 页面可交互
```

**计算指标**:
- 白屏时间 = T2 - T0
- 首屏时间 = T5 - T0
- 可交互时间 = T7 - T0
- DNS解析 = DNS查询时间
- TCP连接 = 连接建立时间

### 8.2 性能监控方案

**Flutter端监控**:
- 使用Stopwatch记录关键时间点
- 统计WebView初始化耗时
- 监控内存占用
- 记录Crash率

**H5端监控**:
- 使用Performance API采集性能数据
- 监控首屏渲染时间
- 统计资源加载耗时
- 记录JS错误

**上报机制**:
- 采样上报（10%用户）
- 批量上报（减少请求）
- 延迟上报（不影响主流程）

### 8.3 性能优化迭代

```
数据采集
    ↓
数据分析（找出瓶颈）
    ↓
制定优化方案
    ↓
实施优化
    ↓
A/B测试验证
    ↓
全量发布
    ↓
持续监控 → 回到数据采集
```

## 9. 优化效果预期

### 9.1 优化前后对比

| 指标 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| 首屏时间 | 2000ms | 300ms | 85% |
| 白屏时间 | 1500ms | 50ms | 97% |
| WebView初始化 | 800ms | 0ms | 100% |
| 资源加载 | 1200ms | 200ms | 83% |
| 内存占用 | 200MB | 120MB | 40% |

### 9.2 分阶段目标

**第一阶段**: 基础优化
- 实现离线包机制
- 添加骨架屏
- 目标首屏 < 1000ms

**第二阶段**: WebView池
- 实现WebView预加载
- 优化资源加载
- 目标首屏 < 500ms

**第三阶段**: 深度优化
- H5代码优化
- 智能预加载
- 目标首屏 < 300ms

## 10. 优化实施优先级

```
P0 (必须): 
├─ 离线包机制 (减少网络依赖)
├─ 骨架屏 (改善体验)
└─ 基础缓存 (提升加载速度)

P1 (重要):
├─ WebView池 (消除初始化时间)
├─ 资源预加载 (提前准备)
└─ 代码分割 (减少首包大小)

P2 (优化):
├─ 智能预测 (提前加载)
├─ 性能监控 (数据驱动)
└─ 极致压缩 (进一步减小体积)
```

## 下一步

详见：[容错降级方案](./05-容错降级方案.md)
