# 资源包管理方案

## 1. 资源包结构设计

### 1.1 标准资源包格式

```
mall-v1.0.0.zip
├── manifest.json           # 元数据清单
├── index.html             # 入口HTML
├── assets/
│   ├── css/
│   │   ├── main.css
│   │   └── vendors.css
│   ├── js/
│   │   ├── main.js       # 业务代码
│   │   ├── vendors.js    # 第三方库
│   │   └── bridge.js     # JSBridge SDK
│   ├── images/
│   │   ├── logo.png
│   │   └── icons/
│   └── fonts/
└── preload/               # 预加载资源（可选）
    └── skeleton.html
```

### 1.2 manifest.json结构

```json
{
  "version": "1.0.0",
  "appId": "com.example.mall",
  "name": "商城首页",
  "description": "商城H5动态资源包",
  "timestamp": "2025-10-23T10:00:00Z",
  "checksum": {
    "algorithm": "sha256",
    "value": "abc123def456..."
  },
  "files": {
    "index.html": {
      "size": 2048,
      "hash": "def456..."
    },
    "assets/js/main.js": {
      "size": 102400,
      "hash": "ghi789..."
    }
  },
  "minFlutterVersion": "3.3.0",
  "minAppVersion": "1.0.0",
  "cdn": {
    "primary": "https://cdn.example.com/mall/v1.0.0/",
    "fallback": "https://backup-cdn.example.com/mall/v1.0.0/"
  },
  "features": {
    "requiresLocation": false,
    "requiresCamera": false,
    "requiresNetwork": true
  },
  "meta": {
    "author": "Mall Team",
    "size": 524288,
    "entryPoint": "index.html"
  }
}
```

## 2. 版本管理策略

### 2.1 版本号规范

采用语义化版本号: `MAJOR.MINOR.PATCH`

- **MAJOR**: 不兼容的API变更
- **MINOR**: 向下兼容的功能新增
- **PATCH**: 向下兼容的问题修正

示例:
- `1.0.0` → 初始版本
- `1.0.1` → Bug修复
- `1.1.0` → 新增功能
- `2.0.0` → 重大改版

### 2.2 版本更新策略

| 策略 | 说明 | 适用场景 |
|------|------|----------|
| 强制更新 | 必须更新才能使用 | 重大Bug修复、安全漏洞 |
| 推荐更新 | 提示用户更新，可跳过 | 新功能上线 |
| 静默更新 | 后台下载，下次启动生效 | 小版本迭代 |
| 灰度更新 | 按比例推送 | A/B测试 |

### 2.3 版本检查API

**请求**:
```http
GET /api/resource/version/check?appId=com.example.mall&currentVersion=1.0.0
```

**响应**:
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "hasUpdate": true,
    "latestVersion": "1.0.1",
    "updateStrategy": "recommend",
    "package": {
      "url": "https://cdn.example.com/mall-v1.0.1.zip",
      "size": 524288,
      "checksum": "sha256:abc123...",
      "releaseNotes": "修复首页加载问题"
    },
    "forceUpdate": false,
    "grayScale": {
      "enabled": true,
      "percentage": 50
    }
  }
}
```

## 3. 资源下载实现

### 3.1 Flutter下载服务

```dart
// lib/hybrid/services/resource_downloader.dart
class ResourceDownloader {
  final Dio _dio;
  
  /// 下载资源包
  Future<String> download({
    required String url,
    required String version,
    DownloadProgressCallback? onProgress,
  }) async {
    // 1. 准备临时目录
    final tempDir = await _getTempDownloadDir(version);
    final zipPath = '$tempDir/package.zip';
    
    try {
      // 2. 下载文件（支持断点续传）
      await _dio.download(
        url,
        zipPath,
        onReceiveProgress: (received, total) {
          if (total != -1) {
            final progress = received / total;
            onProgress?.call(progress, received, total);
          }
        },
        options: Options(
          receiveTimeout: Duration(minutes: 5),
          sendTimeout: Duration(seconds: 30),
        ),
      );
      
      return zipPath;
    } catch (e) {
      // 清理临时文件
      await Directory(tempDir).delete(recursive: true);
      rethrow;
    }
  }
  
  /// 支持断点续传
  Future<String> downloadWithResume({
    required String url,
    required String version,
    DownloadProgressCallback? onProgress,
  }) async {
    final tempDir = await _getTempDownloadDir(version);
    final zipPath = '$tempDir/package.zip';
    
    // 检查已下载的大小
    int downloadedBytes = 0;
    if (await File(zipPath).exists()) {
      downloadedBytes = await File(zipPath).length();
    }
    
    await _dio.download(
      url,
      zipPath,
      options: Options(
        headers: {
          'Range': 'bytes=$downloadedBytes-',
        },
      ),
      onReceiveProgress: (received, total) {
        final actualReceived = downloadedBytes + received;
        final actualTotal = downloadedBytes + total;
        onProgress?.call(
          actualReceived / actualTotal,
          actualReceived,
          actualTotal,
        );
      },
    );
    
    return zipPath;
  }
}
```

### 3.2 下载状态管理

```dart
// lib/hybrid/models/download_state.dart
enum DownloadStatus {
  idle,
  checking,      // 检查版本
  downloading,   // 下载中
  verifying,     // 校验中
  extracting,    // 解压中
  installing,    // 安装中
  completed,     // 完成
  failed,        // 失败
  paused,        // 暂停
}

class DownloadState {
  final DownloadStatus status;
  final double progress;      // 0.0 - 1.0
  final int receivedBytes;
  final int totalBytes;
  final String? errorMessage;
  final String? currentVersion;
  final String? targetVersion;
  
  // 计算属性
  String get progressText => '${(progress * 100).toStringAsFixed(1)}%';
  String get speedText => _formatSpeed();
  String get remainingTimeText => _formatRemainingTime();
}
```

## 4. 完整性校验

### 4.1 SHA256校验实现

```dart
// lib/hybrid/services/resource_verifier.dart
import 'dart:io';
import 'package:crypto/crypto.dart';
import 'dart:convert';

class ResourceVerifier {
  /// 校验文件完整性
  Future<bool> verify({
    required String filePath,
    required String expectedHash,
    String algorithm = 'sha256',
  }) async {
    try {
      final file = File(filePath);
      if (!await file.exists()) {
        return false;
      }
      
      // 计算文件哈希
      final actualHash = await _calculateHash(file, algorithm);
      
      // 比较哈希值（不区分大小写）
      return actualHash.toLowerCase() == expectedHash.toLowerCase();
    } catch (e) {
      print('校验失败: $e');
      return false;
    }
  }
  
  /// 计算文件哈希
  Future<String> _calculateHash(File file, String algorithm) async {
    final reader = file.openRead();
    final hasher = algorithm == 'sha256' ? sha256 : md5;
    
    final digest = await hasher.bind(reader).first;
    return digest.toString();
  }
  
  /// 批量校验资源包内的文件
  Future<bool> verifyPackage({
    required String packageDir,
    required Map<String, dynamic> manifest,
  }) async {
    final files = manifest['files'] as Map<String, dynamic>;
    
    for (final entry in files.entries) {
      final relativePath = entry.key;
      final fileInfo = entry.value as Map<String, dynamic>;
      final expectedHash = fileInfo['hash'] as String;
      
      final fullPath = '$packageDir/$relativePath';
      final isValid = await verify(
        filePath: fullPath,
        expectedHash: expectedHash,
      );
      
      if (!isValid) {
        print('文件校验失败: $relativePath');
        return false;
      }
    }
    
    return true;
  }
}
```

### 4.2 校验失败处理

```dart
class VerificationFailedException implements Exception {
  final String filePath;
  final String expectedHash;
  final String actualHash;
  
  VerificationFailedException({
    required this.filePath,
    required this.expectedHash,
    required this.actualHash,
  });
  
  @override
  String toString() {
    return 'Resource verification failed for $filePath\n'
           'Expected: $expectedHash\n'
           'Actual: $actualHash';
  }
}
```

## 5. 资源解压与安装

### 5.1 解压实现

```dart
// 需要添加依赖: archive: ^3.4.0
import 'package:archive/archive.dart';

class ResourceInstaller {
  /// 解压资源包
  Future<void> extract({
    required String zipPath,
    required String targetDir,
    ProgressCallback? onProgress,
  }) async {
    final bytes = await File(zipPath).readAsBytes();
    final archive = ZipDecoder().decodeBytes(bytes);
    
    int processedFiles = 0;
    final totalFiles = archive.files.length;
    
    for (final file in archive.files) {
      final filename = '$targetDir/${file.name}';
      
      if (file.isFile) {
        final outFile = File(filename);
        await outFile.create(recursive: true);
        await outFile.writeAsBytes(file.content as List<int>);
      } else {
        await Directory(filename).create(recursive: true);
      }
      
      processedFiles++;
      onProgress?.call(processedFiles / totalFiles);
    }
  }
}
```

### 5.2 原子化安装

```dart
class ResourceManager {
  /// 原子化应用新版本
  Future<void> applyVersion(String version) async {
    final tempDir = await _getTempDir(version);
    final targetDir = await _getVersionDir(version);
    final currentPointer = await _getCurrentVersionPointer();
    
    try {
      // 1. 重命名临时目录为正式目录（原子操作）
      await Directory(tempDir).rename(targetDir.path);
      
      // 2. 更新版本指针文件
      await _updateVersionPointer(version);
      
      // 3. 清理旧版本（保留最近3个版本）
      await _cleanOldVersions(keepCount: 3);
      
    } catch (e) {
      // 回滚：恢复旧版本指针
      if (currentPointer != null) {
        await _updateVersionPointer(currentPointer);
      }
      rethrow;
    }
  }
  
  /// 更新版本指针
  Future<void> _updateVersionPointer(String version) async {
    final pointerFile = File('${await _getBaseDir()}/current_version.txt');
    await pointerFile.writeAsString(version);
  }
  
  /// 清理旧版本
  Future<void> _cleanOldVersions({int keepCount = 3}) async {
    final baseDir = await _getBaseDir();
    final versions = await _listVersions();
    
    // 按版本号排序，保留最新的N个
    versions.sort((a, b) => b.compareTo(a));
    
    if (versions.length > keepCount) {
      final toDelete = versions.skip(keepCount);
      for (final version in toDelete) {
        final dir = Directory('$baseDir/$version');
        if (await dir.exists()) {
          await dir.delete(recursive: true);
        }
      }
    }
  }
}
```

## 6. 本地存储管理

### 6.1 目录结构

```
应用沙盒/
└── hybrid_resources/
    ├── current_version.txt          # 当前版本指针
    ├── versions/
    │   ├── 1.0.0/                  # 已安装版本
    │   │   ├── manifest.json
    │   │   ├── index.html
    │   │   └── assets/
    │   ├── 1.0.1/
    │   └── 1.0.2/
    ├── temp/                        # 临时下载目录
    │   └── 1.0.3_downloading/
    └── cache/                       # 缓存
        └── metadata_cache.json
```

### 6.2 存储空间管理

```dart
class StorageManager {
  /// 检查可用空间
  Future<bool> hasEnoughSpace(int requiredBytes) async {
    // iOS: 使用path_provider获取可用空间
    // Android: 使用disk_space插件或platform channel
    
    final freeSpace = await _getAvailableSpace();
    final safetyMargin = 50 * 1024 * 1024; // 保留50MB安全边距
    
    return freeSpace > (requiredBytes + safetyMargin);
  }
  
  /// 清理缓存
  Future<void> clearCache() async {
    final cacheDir = await _getCacheDir();
    if (await cacheDir.exists()) {
      await cacheDir.delete(recursive: true);
      await cacheDir.create();
    }
  }
  
  /// 获取总占用空间
  Future<int> getTotalSize() async {
    final baseDir = await _getBaseDir();
    return await _calculateDirectorySize(baseDir);
  }
}
```

## 7. 后端API实现

### 7.1 版本管理API

```typescript
// backend_module/src/controllers/ResourceController.ts
import { Request, Response } from 'express';
import { ResourceService } from '../services/ResourceService';

export class ResourceController {
  private resourceService: ResourceService;
  
  constructor() {
    this.resourceService = new ResourceService();
  }
  
  /**
   * 检查版本更新
   */
  async checkVersion(req: Request, res: Response) {
    const { appId, currentVersion } = req.query;
    
    try {
      const updateInfo = await this.resourceService.checkForUpdates(
        appId as string,
        currentVersion as string
      );
      
      res.json({
        code: 0,
        message: 'success',
        data: updateInfo
      });
    } catch (error) {
      res.status(500).json({
        code: -1,
        message: error.message
      });
    }
  }
  
  /**
   * 获取资源包元数据
   */
  async getManifest(req: Request, res: Response) {
    const { appId, version } = req.params;
    
    try {
      const manifest = await this.resourceService.getManifest(appId, version);
      res.json(manifest);
    } catch (error) {
      res.status(404).json({
        code: -1,
        message: 'Manifest not found'
      });
    }
  }
}
```

### 7.2 资源服务实现

```typescript
// backend_module/src/services/ResourceService.ts
import * as fs from 'fs';
import * as path from 'path';
import { createHash } from 'crypto';

export class ResourceService {
  private resourceBasePath = path.join(__dirname, '../../public/mall');
  
  /**
   * 检查更新
   */
  async checkForUpdates(appId: string, currentVersion: string) {
    const latestVersion = await this.getLatestVersion(appId);
    const hasUpdate = this.compareVersions(latestVersion, currentVersion) > 0;
    
    if (!hasUpdate) {
      return {
        hasUpdate: false,
        currentVersion,
        latestVersion
      };
    }
    
    const packageInfo = await this.getPackageInfo(appId, latestVersion);
    
    return {
      hasUpdate: true,
      latestVersion,
      updateStrategy: this.determineUpdateStrategy(currentVersion, latestVersion),
      package: packageInfo,
      forceUpdate: packageInfo.forceUpdate || false
    };
  }
  
  /**
   * 获取最新版本号
   */
  private async getLatestVersion(appId: string): Promise<string> {
    const versionsPath = path.join(this.resourceBasePath, 'versions');
    const versions = fs.readdirSync(versionsPath);
    
    // 过滤并排序版本号
    const validVersions = versions
      .filter(v => /^\d+\.\d+\.\d+$/.test(v))
      .sort((a, b) => this.compareVersions(b, a));
    
    return validVersions[0] || '1.0.0';
  }
  
  /**
   * 比较版本号
   */
  private compareVersions(v1: string, v2: string): number {
    const parts1 = v1.split('.').map(Number);
    const parts2 = v2.split('.').map(Number);
    
    for (let i = 0; i < 3; i++) {
      if (parts1[i] > parts2[i]) return 1;
      if (parts1[i] < parts2[i]) return -1;
    }
    return 0;
  }
  
  /**
   * 计算文件哈希
   */
  async calculateFileHash(filePath: string): Promise<string> {
    return new Promise((resolve, reject) => {
      const hash = createHash('sha256');
      const stream = fs.createReadStream(filePath);
      
      stream.on('data', data => hash.update(data));
      stream.on('end', () => resolve(hash.digest('hex')));
      stream.on('error', reject);
    });
  }
}
```

### 7.3 路由配置

```typescript
// backend_module/src/routes/resource.routes.ts
import { Router } from 'express';
import { ResourceController } from '../controllers/ResourceController';

export function registerResourceRoutes(router: Router) {
  const controller = new ResourceController();
  
  // 版本检查
  router.get('/resource/version/check', 
    controller.checkVersion.bind(controller)
  );
  
  // 获取manifest
  router.get('/resource/:appId/:version/manifest', 
    controller.getManifest.bind(controller)
  );
  
  // 静态资源服务
  router.use('/resource/packages', 
    express.static(path.join(__dirname, '../../public/mall/packages'))
  );
}
```

## 8. 测试要点

### 8.1 单元测试

- ✅ 版本号比较逻辑
- ✅ 哈希计算准确性
- ✅ 解压缩功能
- ✅ 原子化安装

### 8.2 集成测试

- ✅ 完整下载流程
- ✅ 断点续传
- ✅ 网络异常处理
- ✅ 存储空间不足

### 8.3 压力测试

- ✅ 大文件下载（>10MB）
- ✅ 并发下载
- ✅ 弱网环境

## 下一步

详见：[原生交互方案](./03-原生交互方案.md)

