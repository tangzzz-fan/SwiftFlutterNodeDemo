# 自定义组件实战

## 1. 组件设计原则

### 1.1 API设计

**优秀的组件API应该**：
```
✅ 直观易懂
✅ 灵活可配置
✅ 类型安全
✅ 有合理的默认值
✅ 文档完善
```

**示例对比**：
```dart
// ❌ 不好的API
CustomButton(
  text: 'Click',
  color: Colors.blue,
  textColor: Colors.white,
  borderRadius: 8.0,
  padding: EdgeInsets.all(16),
  // ... 30个参数
)

// ✅ 好的API
CustomButton(
  'Click',
  onPressed: () {},
  style: ButtonStyle.primary, // 预设样式
  size: ButtonSize.medium,    // 预设尺寸
  icon: Icons.star,           // 可选icon
)
```

### 1.2 组件分类

```
按功能分：
├─ 布局组件（Layout）- 组织其他组件
├─ 容器组件（Container）- 装饰和约束
├─ 展示组件（Display）- 显示数据
├─ 交互组件（Interactive）- 响应用户操作
└─ 复合组件（Composite）- 组合多个组件

按复杂度分：
├─ 简单组件 - StatelessWidget
├─ 状态组件 - StatefulWidget
└─ 渲染组件 - RenderObjectWidget
```

## 2. 自定义StatelessWidget

### 2.1 基础结构

```dart
class CustomCard extends StatelessWidget {
  const CustomCard({
    Key? key,
    required this.title,
    required this.subtitle,
    this.leading,
    this.trailing,
    this.onTap,
    this.padding,
    this.elevation = 2.0,
  }) : super(key: key);

  final String title;
  final String subtitle;
  final Widget? leading;
  final Widget? trailing;
  final VoidCallback? onTap;
  final EdgeInsetsGeometry? padding;
  final double elevation;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Card(
      elevation: elevation,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: padding ?? const EdgeInsets.all(16.0),
          child: Row(
            children: [
              if (leading != null) ...[
                leading!,
                const SizedBox(width: 16),
              ],
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: theme.textTheme.titleMedium,
                    ),
                    const SizedBox(height: 4),
                    Text(
                      subtitle,
                      style: theme.textTheme.bodySmall,
                    ),
                  ],
                ),
              ),
              if (trailing != null) ...[
                const SizedBox(width: 16),
                trailing!,
              ],
            ],
          ),
        ),
      ),
    );
  }
}

// 使用
CustomCard(
  title: 'Product Name',
  subtitle: 'Description',
  leading: Icon(Icons.shopping_cart),
  trailing: Icon(Icons.chevron_right),
  onTap: () => print('Tapped'),
)
```

### 2.2 主题适配

```dart
class ThemedButton extends StatelessWidget {
  const ThemedButton({
    Key? key,
    required this.text,
    required this.onPressed,
    this.type = ButtonType.primary,
  }) : super(key: key);

  final String text;
  final VoidCallback? onPressed;
  final ButtonType type;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    // 根据主题和类型决定样式
    final buttonStyle = _getButtonStyle(theme);
    
    return ElevatedButton(
      onPressed: onPressed,
      style: buttonStyle,
      child: Text(text),
    );
  }
  
  ButtonStyle _getButtonStyle(ThemeData theme) {
    switch (type) {
      case ButtonType.primary:
        return ElevatedButton.styleFrom(
          backgroundColor: theme.primaryColor,
          foregroundColor: theme.colorScheme.onPrimary,
        );
      case ButtonType.secondary:
        return ElevatedButton.styleFrom(
          backgroundColor: theme.colorScheme.secondary,
          foregroundColor: theme.colorScheme.onSecondary,
        );
      case ButtonType.danger:
        return ElevatedButton.styleFrom(
          backgroundColor: theme.colorScheme.error,
          foregroundColor: theme.colorScheme.onError,
        );
    }
  }
}

enum ButtonType { primary, secondary, danger }
```

### 2.3 响应式设计

```dart
class ResponsiveContainer extends StatelessWidget {
  const ResponsiveContainer({
    Key? key,
    required this.child,
    this.mobileMaxWidth = 600,
    this.tabletMaxWidth = 1200,
  }) : super(key: key);

  final Widget child;
  final double mobileMaxWidth;
  final double tabletMaxWidth;

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final width = constraints.maxWidth;
        
        // 根据宽度决定布局
        if (width < mobileMaxWidth) {
          return _buildMobileLayout();
        } else if (width < tabletMaxWidth) {
          return _buildTabletLayout();
        } else {
          return _buildDesktopLayout();
        }
      },
    );
  }
  
  Widget _buildMobileLayout() {
    return Column(children: [child]);
  }
  
  Widget _buildTabletLayout() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 32),
      child: child,
    );
  }
  
  Widget _buildDesktopLayout() {
    return Center(
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxWidth: 1200),
        child: child,
      ),
    );
  }
}
```

## 3. 自定义StatefulWidget

### 3.1 可展开卡片组件

```dart
class ExpandableCard extends StatefulWidget {
  const ExpandableCard({
    Key? key,
    required this.title,
    required this.content,
    this.initiallyExpanded = false,
    this.onExpansionChanged,
  }) : super(key: key);

  final String title;
  final Widget content;
  final bool initiallyExpanded;
  final ValueChanged<bool>? onExpansionChanged;

  @override
  State<ExpandableCard> createState() => _ExpandableCardState();
}

class _ExpandableCardState extends State<ExpandableCard>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;
  late bool _isExpanded;

  @override
  void initState() {
    super.initState();
    _isExpanded = widget.initiallyExpanded;
    
    _controller = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    
    _animation = CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    );
    
    if (_isExpanded) {
      _controller.value = 1.0;
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _toggleExpansion() {
    setState(() {
      _isExpanded = !_isExpanded;
      if (_isExpanded) {
        _controller.forward();
      } else {
        _controller.reverse();
      }
      widget.onExpansionChanged?.call(_isExpanded);
    });
  }

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Column(
        children: [
          // 标题栏
          InkWell(
            onTap: _toggleExpansion,
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Row(
                children: [
                  Expanded(
                    child: Text(
                      widget.title,
                      style: Theme.of(context).textTheme.titleMedium,
                    ),
                  ),
                  RotationTransition(
                    turns: Tween(begin: 0.0, end: 0.5).animate(_animation),
                    child: const Icon(Icons.expand_more),
                  ),
                ],
              ),
            ),
          ),
          
          // 可展开内容
          SizeTransition(
            sizeFactor: _animation,
            child: Padding(
              padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
              child: widget.content,
            ),
          ),
        ],
      ),
    );
  }
}

// 使用
ExpandableCard(
  title: 'Details',
  content: Text('This is the content...'),
  initiallyExpanded: true,
  onExpansionChanged: (expanded) {
    print('Expanded: $expanded');
  },
)
```

### 3.2 评分组件

```dart
class StarRating extends StatefulWidget {
  const StarRating({
    Key? key,
    this.rating = 0.0,
    this.maxRating = 5,
    this.size = 24.0,
    this.color = Colors.amber,
    this.borderColor = Colors.grey,
    this.onRatingChanged,
    this.allowHalfRating = true,
    this.readOnly = false,
  }) : super(key: key);

  final double rating;
  final int maxRating;
  final double size;
  final Color color;
  final Color borderColor;
  final ValueChanged<double>? onRatingChanged;
  final bool allowHalfRating;
  final bool readOnly;

  @override
  State<StarRating> createState() => _StarRatingState();
}

class _StarRatingState extends State<StarRating> {
  late double _currentRating;

  @override
  void initState() {
    super.initState();
    _currentRating = widget.rating;
  }

  @override
  void didUpdateWidget(StarRating oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.rating != oldWidget.rating) {
      _currentRating = widget.rating;
    }
  }

  void _updateRating(double localX, double starWidth) {
    if (widget.readOnly) return;
    
    final starIndex = (localX / starWidth).floor();
    final starPosition = (localX % starWidth) / starWidth;
    
    double newRating;
    if (widget.allowHalfRating) {
      newRating = starIndex + (starPosition > 0.5 ? 1.0 : 0.5);
    } else {
      newRating = starIndex + (starPosition > 0.5 ? 1.0 : 0.0);
    }
    
    newRating = newRating.clamp(0.0, widget.maxRating.toDouble());
    
    setState(() {
      _currentRating = newRating;
    });
    
    widget.onRatingChanged?.call(newRating);
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTapDown: widget.readOnly
          ? null
          : (details) {
              final starWidth = widget.size + 4;
              _updateRating(details.localPosition.dx, starWidth);
            },
      onPanUpdate: widget.readOnly
          ? null
          : (details) {
              final starWidth = widget.size + 4;
              _updateRating(details.localPosition.dx, starWidth);
            },
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: List.generate(widget.maxRating, (index) {
          return Padding(
            padding: const EdgeInsets.symmetric(horizontal: 2),
            child: _buildStar(index),
          );
        }),
      ),
    );
  }

  Widget _buildStar(int index) {
    final diff = _currentRating - index;
    
    if (diff >= 1.0) {
      // 全星
      return Icon(
        Icons.star,
        size: widget.size,
        color: widget.color,
      );
    } else if (diff >= 0.5) {
      // 半星
      return Icon(
        Icons.star_half,
        size: widget.size,
        color: widget.color,
      );
    } else {
      // 空星
      return Icon(
        Icons.star_border,
        size: widget.size,
        color: widget.borderColor,
      );
    }
  }
}

// 使用
StarRating(
  rating: 3.5,
  onRatingChanged: (rating) {
    print('New rating: $rating');
  },
)
```

### 3.3 图片裁剪器

```dart
class ImageCropper extends StatefulWidget {
  const ImageCropper({
    Key? key,
    required this.image,
    this.aspectRatio = 1.0,
    this.onCropComplete,
  }) : super(key: key);

  final ImageProvider image;
  final double aspectRatio;
  final ValueChanged<Rect>? onCropComplete;

  @override
  State<ImageCropper> createState() => _ImageCropperState();
}

class _ImageCropperState extends State<ImageCropper> {
  Offset _cropPosition = Offset.zero;
  double _cropSize = 200.0;
  double _scale = 1.0;
  
  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        // 底层图片
        Positioned.fill(
          child: Image(
            image: widget.image,
            fit: BoxFit.contain,
          ),
        ),
        
        // 裁剪框
        Positioned(
          left: _cropPosition.dx,
          top: _cropPosition.dy,
          child: GestureDetector(
            onPanUpdate: (details) {
              setState(() {
                _cropPosition += details.delta;
              });
            },
            child: Container(
              width: _cropSize,
              height: _cropSize / widget.aspectRatio,
              decoration: BoxDecoration(
                border: Border.all(color: Colors.white, width: 2),
              ),
              child: Stack(
                children: [
                  // 四个角的调整手柄
                  _buildCornerHandle(Alignment.topLeft),
                  _buildCornerHandle(Alignment.topRight),
                  _buildCornerHandle(Alignment.bottomLeft),
                  _buildCornerHandle(Alignment.bottomRight),
                ],
              ),
            ),
          ),
        ),
        
        // 确认按钮
        Positioned(
          bottom: 20,
          right: 20,
          child: FloatingActionButton(
            child: const Icon(Icons.check),
            onPressed: _onCropComplete,
          ),
        ),
      ],
    );
  }
  
  Widget _buildCornerHandle(Alignment alignment) {
    return Align(
      alignment: alignment,
      child: GestureDetector(
        onPanUpdate: (details) {
          setState(() {
            _cropSize += details.delta.dx;
            _cropSize = _cropSize.clamp(100.0, 400.0);
          });
        },
        child: Container(
          width: 20,
          height: 20,
          decoration: BoxDecoration(
            color: Colors.white,
            shape: BoxShape.circle,
            border: Border.all(color: Colors.blue, width: 2),
          ),
        ),
      ),
    );
  }
  
  void _onCropComplete() {
    final cropRect = Rect.fromLTWH(
      _cropPosition.dx,
      _cropPosition.dy,
      _cropSize,
      _cropSize / widget.aspectRatio,
    );
    widget.onCropComplete?.call(cropRect);
  }
}
```

## 4. 自定义RenderObject（高级）

### 4.1 何时需要自定义RenderObject

```
✅ 需要自定义布局算法
✅ 需要自定义绘制逻辑
✅ 性能要求极高
✅ 现有Widget无法满足

❌ 简单的UI组合（用Widget）
❌ 简单的动画（用AnimatedWidget）
```

### 4.2 自定义布局：流式布局

```dart
// 1. 定义RenderObject
class RenderFlowLayout extends RenderBox
    with
        ContainerRenderObjectMixin<RenderBox, FlowLayoutParentData>,
        RenderBoxContainerDefaultsMixin<RenderBox, FlowLayoutParentData> {
  
  RenderFlowLayout({
    required double spacing,
  }) : _spacing = spacing;

  double _spacing;
  double get spacing => _spacing;
  set spacing(double value) {
    if (_spacing == value) return;
    _spacing = value;
    markNeedsLayout();
  }

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! FlowLayoutParentData) {
      child.parentData = FlowLayoutParentData();
    }
  }

  @override
  void performLayout() {
    if (firstChild == null) {
      size = constraints.smallest;
      return;
    }

    var child = firstChild;
    double x = 0;
    double y = 0;
    double rowHeight = 0;

    while (child != null) {
      final childParentData = child.parentData as FlowLayoutParentData;
      
      // 布局子元素
      child.layout(constraints.loosen(), parentUsesSize: true);
      
      // 如果当前行放不下，换行
      if (x + child.size.width > constraints.maxWidth) {
        x = 0;
        y += rowHeight + _spacing;
        rowHeight = 0;
      }
      
      // 设置子元素位置
      childParentData.offset = Offset(x, y);
      
      // 更新位置
      x += child.size.width + _spacing;
      rowHeight = max(rowHeight, child.size.height);
      
      child = childParentData.nextSibling;
    }

    // 设置自己的大小
    size = Size(
      constraints.maxWidth,
      y + rowHeight,
    );
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    defaultPaint(context, offset);
  }
}

// 2. 定义ParentData
class FlowLayoutParentData extends ContainerBoxParentData<RenderBox> {}

// 3. 定义Widget
class FlowLayout extends MultiChildRenderObjectWidget {
  const FlowLayout({
    Key? key,
    required List<Widget> children,
    this.spacing = 8.0,
  }) : super(key: key, children: children);

  final double spacing;

  @override
  RenderFlowLayout createRenderObject(BuildContext context) {
    return RenderFlowLayout(spacing: spacing);
  }

  @override
  void updateRenderObject(
    BuildContext context,
    RenderFlowLayout renderObject,
  ) {
    renderObject.spacing = spacing;
  }
}

// 使用
FlowLayout(
  spacing: 10,
  children: [
    Chip(label: Text('Tag 1')),
    Chip(label: Text('Tag 2')),
    Chip(label: Text('Long Tag 3')),
    // ...
  ],
)
```

### 4.3 自定义绘制：进度环

```dart
class CircularProgress extends LeafRenderObjectWidget {
  const CircularProgress({
    Key? key,
    required this.progress,
    this.color = Colors.blue,
    this.backgroundColor = Colors.grey,
    this.strokeWidth = 8.0,
  }) : super(key: key);

  final double progress;
  final Color color;
  final Color backgroundColor;
  final double strokeWidth;

  @override
  RenderObject createRenderObject(BuildContext context) {
    return RenderCircularProgress(
      progress: progress,
      color: color,
      backgroundColor: backgroundColor,
      strokeWidth: strokeWidth,
    );
  }

  @override
  void updateRenderObject(
    BuildContext context,
    RenderCircularProgress renderObject,
  ) {
    renderObject
      ..progress = progress
      ..color = color
      ..backgroundColor = backgroundColor
      ..strokeWidth = strokeWidth;
  }
}

class RenderCircularProgress extends RenderBox {
  RenderCircularProgress({
    required double progress,
    required Color color,
    required Color backgroundColor,
    required double strokeWidth,
  })  : _progress = progress,
        _color = color,
        _backgroundColor = backgroundColor,
        _strokeWidth = strokeWidth;

  double _progress;
  double get progress => _progress;
  set progress(double value) {
    if (_progress == value) return;
    _progress = value;
    markNeedsPaint();
  }

  Color _color;
  Color get color => _color;
  set color(Color value) {
    if (_color == value) return;
    _color = value;
    markNeedsPaint();
  }

  Color _backgroundColor;
  Color get backgroundColor => _backgroundColor;
  set backgroundColor(Color value) {
    if (_backgroundColor == value) return;
    _backgroundColor = value;
    markNeedsPaint();
  }

  double _strokeWidth;
  double get strokeWidth => _strokeWidth;
  set strokeWidth(double value) {
    if (_strokeWidth == value) return;
    _strokeWidth = value;
    markNeedsPaint();
  }

  @override
  void performLayout() {
    size = constraints.constrain(const Size(100, 100));
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    final canvas = context.canvas;
    final center = offset + Offset(size.width / 2, size.height / 2);
    final radius = min(size.width, size.height) / 2 - _strokeWidth / 2;

    // 绘制背景圆环
    final bgPaint = Paint()
      ..color = _backgroundColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = _strokeWidth;

    canvas.drawCircle(center, radius, bgPaint);

    // 绘制进度圆弧
    final progressPaint = Paint()
      ..color = _color
      ..style = PaintingStyle.stroke
      ..strokeWidth = _strokeWidth
      ..strokeCap = StrokeCap.round;

    final sweepAngle = 2 * pi * _progress;
    canvas.drawArc(
      Rect.fromCircle(center: center, radius: radius),
      -pi / 2, // 从顶部开始
      sweepAngle,
      false,
      progressPaint,
    );
  }
}
```

## 5. 组件测试

### 5.1 Widget测试

```dart
void main() {
  testWidgets('CustomButton shows text', (tester) async {
    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: CustomButton(
            text: 'Click Me',
            onPressed: () {},
          ),
        ),
      ),
    );

    expect(find.text('Click Me'), findsOneWidget);
  });

  testWidgets('CustomButton calls onPressed', (tester) async {
    bool pressed = false;

    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: CustomButton(
            text: 'Click Me',
            onPressed: () => pressed = true,
          ),
        ),
      ),
    );

    await tester.tap(find.text('Click Me'));
    expect(pressed, isTrue);
  });
}
```

## 6. 最佳实践总结

### 6.1 组件设计清单

```
✅ 明确的职责
✅ 简洁的API
✅ 合理的默认值
✅ const构造函数
✅ 良好的文档
✅ 完整的测试
```

### 6.2 性能优化

```
✅ 使用const构造函数
✅ 避免在build中创建对象
✅ 实现shouldRebuild（InheritedWidget）
✅ 使用Key复用Widget
✅ 缓存计算结果
```

### 6.3 可维护性

```
✅ 单一职责
✅ 组合优于继承
✅ 提取魔法数字为常量
✅ 使用枚举而不是字符串
✅ 完善的注释
```

## 7. 核心要点

1. **选择合适的基类**：StatelessWidget、StatefulWidget、RenderObjectWidget
2. **API设计**：直观、灵活、类型安全
3. **性能优化**：const、避免重建、缓存
4. **测试**：Widget测试保证质量
5. **文档**：清晰的文档和示例

自定义组件是Flutter的核心能力，掌握它就能构建任何UI！

