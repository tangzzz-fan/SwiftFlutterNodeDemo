# 手势与事件处理

## 1. 触摸事件机制

### 1.1 事件流转过程

**完整流程**：
```
用户触摸屏幕
    ↓
系统捕获触摸事件
    ↓
Flutter Engine接收
    ↓
GestureBinding处理
    ↓
命中测试（Hit Test）
    ↓
找到响应的Widget
    ↓
手势识别器竞技场（Gesture Arena）
    ↓
确定胜者
    ↓
触发回调
```

### 1.2 命中测试（Hit Test）

**原理**：从上到下遍历RenderObject树，找出触摸点下的所有Widget

```
触摸点: (100, 200)
    ↓
Root RenderObject
  ├─ Child A (0,0,200,300) ✅ 命中
  │   └─ Child A1 (50,50,150,250) ✅ 命中
  └─ Child B (300,0,500,400) ❌ 未命中
  
结果：[Child A1, Child A, Root]
```

**hit test流程**：
```dart
bool hitTest(HitTestResult result, Offset position) {
  // 1. 检查自己是否被命中
  if (!size.contains(position)) {
    return false;
  }
  
  // 2. 检查子节点（从后往前，因为后面的在上层）
  for (final child in children.reversed) {
    if (child.hitTest(result, position - child.offset)) {
      // 子节点命中，添加到结果
      result.add(child);
      return true;
    }
  }
  
  // 3. 子节点都没命中，检查自己
  if (hitTestSelf(position)) {
    result.add(this);
    return true;
  }
  
  return false;
}
```

### 1.3 手势识别器竞技场

**问题**：一个触摸事件可能被多个手势识别器捕获，如何决定谁处理？

**竞技场机制**：
```
触摸开始
    ↓
所有识别器进入竞技场
    ↓
每个识别器判断手势
  ├─ TapGestureRecognizer：等待抬起
  ├─ LongPressGestureRecognizer：等待时间
  └─ PanGestureRecognizer：等待移动
    ↓
某个识别器确认（accept）
    ↓
其他识别器拒绝（reject）
    ↓
胜者触发回调
```

**示例场景**：
```
用户按下屏幕
├─ Tap识别器：等待抬起（pending）
├─ LongPress识别器：开始计时（pending）
└─ Pan识别器：等待移动（pending）

500ms后，用户未抬起也未移动
├─ Tap识别器：拒绝（reject）
├─ LongPress识别器：确认（accept）← 胜者
└─ Pan识别器：拒绝（reject）

触发 onLongPress 回调
```

## 2. GestureDetector深度解析

### 2.1 核心属性

```dart
GestureDetector(
  // 点击事件
  onTap: () {},
  onTapDown: (details) {},
  onTapUp: (details) {},
  onTapCancel: () {},
  
  // 双击
  onDoubleTap: () {},
  
  // 长按
  onLongPress: () {},
  onLongPressStart: (details) {},
  onLongPressMoveUpdate: (details) {},
  onLongPressEnd: (details) {},
  
  // 垂直拖动
  onVerticalDragStart: (details) {},
  onVerticalDragUpdate: (details) {},
  onVerticalDragEnd: (details) {},
  
  // 水平拖动
  onHorizontalDragStart: (details) {},
  onHorizontalDragUpdate: (details) {},
  onHorizontalDragEnd: (details) {},
  
  // 缩放
  onScaleStart: (details) {},
  onScaleUpdate: (details) {},
  onScaleEnd: (details) {},
  
  // 行为配置
  behavior: HitTestBehavior.opaque,
  
  child: Container(...),
)
```

### 2.2 HitTestBehavior

**三种行为**：

```dart
enum HitTestBehavior {
  // 只有可见区域响应（默认）
  deferToChild,
  
  // 整个区域响应（包括透明区域）
  opaque,
  
  // 穿透到下层Widget
  translucent,
}
```

**场景对比**：
```
Container(
  width: 100,
  height: 100,
  color: Colors.transparent, // 透明
  child: GestureDetector(
    behavior: HitTestBehavior.deferToChild, // ❌ 透明区域无法点击
    behavior: HitTestBehavior.opaque,       // ✅ 整个区域都可点击
    onTap: () => print('Tapped'),
    child: Center(child: Text('Click')),
  ),
)
```

### 2.3 事件详情（Details）

**TapDownDetails**：
```dart
onTapDown: (details) {
  details.globalPosition; // 全局坐标
  details.localPosition;  // 组件内坐标
  details.kind;           // 触摸类型（touch/mouse/stylus）
}
```

**DragUpdateDetails**：
```dart
onPanUpdate: (details) {
  details.delta;           // 移动增量
  details.globalPosition;  // 当前全局位置
  details.localPosition;   // 当前局部位置
  details.primaryDelta;    // 主方向移动量
}
```

**ScaleUpdateDetails**：
```dart
onScaleUpdate: (details) {
  details.scale;           // 缩放比例
  details.rotation;        // 旋转角度
  details.focalPoint;      // 焦点位置
  details.pointerCount;    // 触摸点数量
}
```

## 3. 手势冲突处理

### 3.1 常见冲突场景

**场景1：垂直滚动 vs 水平滚动**

```dart
// ❌ 冲突：两个方向都监听
GestureDetector(
  onVerticalDragUpdate: (details) {},
  onHorizontalDragUpdate: (details) {},
  // 只能识别一个方向
)

// ✅ 解决：使用onPan（全方向）
GestureDetector(
  onPanUpdate: (details) {
    if (details.delta.dx.abs() > details.delta.dy.abs()) {
      // 水平方向为主
    } else {
      // 垂直方向为主
    }
  },
)
```

**场景2：列表滚动 vs 侧滑删除**

```
ListView（垂直滚动）
  └─ Dismissible（水平滑动）
  
问题：两者都监听拖动，冲突

解决：
1. Dismissible有更高优先级（内层）
2. 水平滑动时，ListView不响应
3. 垂直滑动时，Dismissible不响应
```

**场景3：点击 vs 长按**

```dart
GestureDetector(
  onTap: () => print('Tap'),
  onLongPress: () => print('Long Press'),
  // Flutter自动处理：
  // - 快速抬起 → Tap
  // - 持续按下 → Long Press
)
```

### 3.2 RawGestureDetector

**更精细的控制**：

```dart
RawGestureDetector(
  gestures: {
    // 自定义识别器
    TapGestureRecognizer: GestureRecognizerFactoryWithHandlers<
      TapGestureRecognizer
    >(
      () => TapGestureRecognizer(),
      (instance) {
        instance.onTap = () => print('Tap');
      },
    ),
    
    // 自定义竞技场行为
    PanGestureRecognizer: GestureRecognizerFactoryWithHandlers<
      PanGestureRecognizer
    >(
      () => PanGestureRecognizer(),
      (instance) {
        instance
          ..onStart = (details) {}
          ..onUpdate = (details) {}
          ..onEnd = (details) {};
      },
    ),
  },
  child: Container(...),
)
```

### 3.3 手势优先级控制

**嵌套手势**：
```dart
GestureDetector(
  onTap: () => print('Outer'),
  child: GestureDetector(
    onTap: () => print('Inner'),
    // 默认：Inner优先
  ),
)
```

**阻止事件冒泡**：
```dart
GestureDetector(
  behavior: HitTestBehavior.opaque, // 阻止向下传递
  onTap: () {
    print('Handle here');
    // 不会触发外层的onTap
  },
  child: ...,
)
```

## 4. Listener - 原始指针事件

### 4.1 Pointer Events

**更底层的事件**：

```dart
Listener(
  onPointerDown: (event) {
    // 手指按下
    event.position;     // 位置
    event.pointer;      // 触摸点ID
    event.kind;         // 输入设备类型
  },
  
  onPointerMove: (event) {
    // 手指移动
    event.delta;        // 移动增量
    event.distance;     // 移动距离
  },
  
  onPointerUp: (event) {
    // 手指抬起
  },
  
  onPointerCancel: (event) {
    // 事件取消
  },
  
  onPointerHover: (event) {
    // 鼠标悬停（Web/Desktop）
  },
  
  child: Container(...),
)
```

### 4.2 Listener vs GestureDetector

| 特性 | Listener | GestureDetector |
|------|----------|-----------------|
| 级别 | 原始事件 | 手势识别 |
| 回调 | 4个基础回调 | 30+手势回调 |
| 语义 | 低级（position, delta） | 高级（tap, drag, scale） |
| 竞技场 | ❌ 不参与 | ✅ 参与 |
| 适用场景 | 自定义手势 | 常规交互 |

**何时使用Listener**：
```
✅ 需要精确控制触摸点
✅ 多点触控处理
✅ 自定义复杂手势
✅ 绕过手势竞技场
```

### 4.3 多点触控

**追踪多个触摸点**：

```dart
class MultiTouchWidget extends StatefulWidget {
  @override
  _MultiTouchWidgetState createState() => _MultiTouchWidgetState();
}

class _MultiTouchWidgetState extends State<MultiTouchWidget> {
  Map<int, Offset> _pointers = {};
  
  @override
  Widget build(BuildContext context) {
    return Listener(
      onPointerDown: (event) {
        setState(() {
          _pointers[event.pointer] = event.position;
        });
      },
      
      onPointerMove: (event) {
        setState(() {
          _pointers[event.pointer] = event.position;
        });
      },
      
      onPointerUp: (event) {
        setState(() {
          _pointers.remove(event.pointer);
        });
      },
      
      child: CustomPaint(
        painter: MultiTouchPainter(_pointers),
        child: Container(),
      ),
    );
  }
}
```

## 5. 事件冒泡与拦截

### 5.1 事件传递链

**由内到外**：
```
Child Widget (最内层)
    ↓ 事件向上冒泡
Parent Widget
    ↓
Grand Parent Widget
    ↓
Root Widget
```

### 5.2 AbsorbPointer vs IgnorePointer

**阻止事件传递**：

```dart
// AbsorbPointer - 吸收事件
Stack(
  children: [
    GestureDetector(
      onTap: () => print('Background'),
      child: Container(color: Colors.blue),
    ),
    AbsorbPointer(
      absorbing: true,
      child: GestureDetector(
        onTap: () => print('Never called'),
        child: Container(color: Colors.red),
      ),
    ),
  ],
)
// 点击红色区域：什么都不发生（事件被吸收）

// IgnorePointer - 忽略自己，传递给下层
Stack(
  children: [
    GestureDetector(
      onTap: () => print('Background'),
      child: Container(color: Colors.blue),
    ),
    IgnorePointer(
      ignoring: true,
      child: GestureDetector(
        onTap: () => print('Never called'),
        child: Container(color: Colors.red),
      ),
    ),
  ],
)
// 点击红色区域：触发Background的onTap（事件穿透）
```

**区别**：
```
AbsorbPointer:
- 阻止事件向下传递
- 自己参与hit test
- 子树不接收事件

IgnorePointer:
- 不参与hit test
- 整个子树被跳过
- 事件传递给下层Widget
```

## 6. 性能优化

### 6.1 避免过度rebuild

**问题**：
```dart
// ❌ 每次移动都setState，导致整个Widget树rebuild
onPanUpdate: (details) {
  setState(() {
    position = details.globalPosition;
  });
}
```

**优化**：
```dart
// ✅ 使用ValueNotifier，只rebuild需要的部分
class DragWidget extends StatefulWidget {
  @override
  _DragWidgetState createState() => _DragWidgetState();
}

class _DragWidgetState extends State<DragWidget> {
  final position = ValueNotifier<Offset>(Offset.zero);
  
  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onPanUpdate: (details) {
        // 不调用setState，只更新ValueNotifier
        position.value = details.globalPosition;
      },
      child: ValueListenableBuilder<Offset>(
        valueListenable: position,
        builder: (context, pos, child) {
          // 只有这部分rebuild
          return Transform.translate(
            offset: pos,
            child: child,
          );
        },
        child: Container(...), // 这部分不rebuild
      ),
    );
  }
}
```

### 6.2 手势节流

**问题**：高频触发导致性能问题

**解决**：
```dart
DateTime? _lastUpdate;
final _throttleMs = 16; // 约60fps

onPanUpdate: (details) {
  final now = DateTime.now();
  if (_lastUpdate != null &&
      now.difference(_lastUpdate!).inMilliseconds < _throttleMs) {
    return; // 跳过
  }
  
  _lastUpdate = now;
  // 处理事件
}
```

### 6.3 减少hit test范围

```dart
// ✅ 使用SizedBox限制hit test区域
SizedBox(
  width: 100,
  height: 100,
  child: GestureDetector(
    behavior: HitTestBehavior.opaque,
    onTap: () {},
    child: ...,
  ),
)

// 而不是整个屏幕都可点击
```

## 7. 最佳实践

### 7.1 选择合适的手势组件

```
简单点击 → InkWell / InkResponse（Material波纹效果）
复杂手势 → GestureDetector
原始事件 → Listener
自定义手势 → RawGestureDetector
```

### 7.2 手势语义化

```dart
// ✅ 明确的手势意图
GestureDetector(
  onTap: _handleTap,
  onLongPress: _handleLongPress,
  child: ...,
)

// 而不是
Listener(
  onPointerDown: _handlePointer,
  // 需要自己判断是tap还是longPress
)
```

### 7.3 防抖动

```dart
// 防止快速重复点击
bool _isProcessing = false;

onTap: () async {
  if (_isProcessing) return;
  
  _isProcessing = true;
  try {
    await processAction();
  } finally {
    _isProcessing = false;
  }
}
```

### 7.4 手势反馈

```
✅ 提供视觉反馈（高亮、缩放）
✅ 提供触觉反馈（震动）
✅ 提供音频反馈（可选）
```

## 8. 核心要点

记住这些关键概念：

1. **事件流程**：触摸 → Hit Test → 竞技场 → 回调
2. **GestureDetector**：高级手势识别，参与竞技场
3. **Listener**：原始事件，不参与竞技场
4. **冲突处理**：理解竞技场机制，合理使用RawGestureDetector
5. **性能优化**：避免过度rebuild，使用节流
6. **事件拦截**：AbsorbPointer吸收，IgnorePointer穿透

理解了手势处理机制，就能实现流畅自然的用户交互！

