# 实战：蓝牙设备数据可视化组件

## 1. 场景分析

### 1.1 业务场景

**户外储能设备监控**：
- iOS通过蓝牙连接储能设备
- 持续接收设备数据（功率、电量、温度等）
- Flutter端实时展示和绘制图表
- 数据更新频率：1-2秒/次

### 1.2 技术挑战

```
核心挑战：
✅ 实时数据流处理（高频更新）
✅ Platform Channel通信优化
✅ 图表性能优化（避免卡顿）
✅ 数据缓存与历史记录
✅ 异常断连处理
✅ 状态同步
```

## 2. 整体架构设计

### 2.1 分层架构

```
┌─────────────────────────────────────────────────┐
│            iOS Native Layer                     │
│  ┌──────────────┐  ┌──────────────┐            │
│  │ CoreBluetooth│  │ BLE Manager  │            │
│  └──────────────┘  └──────────────┘            │
└─────────────────────────────────────────────────┘
              ↓ Platform Channel (EventChannel)
┌─────────────────────────────────────────────────┐
│         Flutter Platform Bridge                 │
│  ┌──────────────────────────────────────┐       │
│  │ BluetoothDataBridge                  │       │
│  │ - 数据格式转换                        │       │
│  │ - 错误处理                            │       │
│  └──────────────────────────────────────┘       │
└─────────────────────────────────────────────────┘
              ↓ Stream
┌─────────────────────────────────────────────────┐
│         Riverpod State Layer                    │
│  ┌──────────────┐  ┌──────────────┐            │
│  │ Device State │  │ Chart Data   │            │
│  │ Provider     │  │ Provider     │            │
│  └──────────────┘  └──────────────┘            │
└─────────────────────────────────────────────────┘
              ↓ watch
┌─────────────────────────────────────────────────┐
│            UI Layer                              │
│  ┌──────────────┐  ┌──────────────┐            │
│  │ Device Card  │  │ Chart Widget │            │
│  └──────────────┘  └──────────────┘            │
└─────────────────────────────────────────────────┘
```

### 2.2 数据流设计

```
[蓝牙设备] 
    ↓ BLE数据包
[iOS CoreBluetooth] 
    ↓ 解析+封装
[EventChannel Stream] 
    ↓ JSON字符串
[Flutter Bridge] 
    ↓ 反序列化
[DeviceDataNotifier]
    ├─ 更新当前状态
    ├─ 追加历史数据
    └─ 触发UI更新
    ↓
[UI重建]
    ├─ 设备状态卡片
    └─ 实时图表
```

## 3. Platform Channel设计

### 3.1 EventChannel通信

**为什么用EventChannel？**
```
MethodChannel：
- 请求-响应模式
- 需要Flutter主动调用
- 适合：偶尔的数据获取

EventChannel：✅ 推荐
- Native主动推送
- 持续的数据流
- 适合：实时数据监控
```

**iOS端实现原理**：
```swift
// 1. 创建EventChannel
let channel = FlutterEventChannel(
  name: "device_data_stream",
  binaryMessenger: messenger
)

// 2. 设置StreamHandler
channel.setStreamHandler(DeviceDataStreamHandler())

// 3. StreamHandler实现
class DeviceDataStreamHandler: NSObject, FlutterStreamHandler {
  private var eventSink: FlutterEventSink?
  
  func onListen(withArguments args: Any?, 
                eventSink events: @escaping FlutterEventSink) -> FlutterError? {
    self.eventSink = events
    
    // 启动蓝牙数据监听
    startBluetoothDataListener()
    return nil
  }
  
  func onCancel(withArguments args: Any?) -> FlutterError? {
    // 停止监听
    stopBluetoothDataListener()
    eventSink = nil
    return nil
  }
  
  // 收到蓝牙数据时调用
  func onBluetoothDataReceived(_ data: DeviceData) {
    let json = data.toJSON()
    eventSink?(json) // 推送给Flutter
  }
}
```

**Flutter端接收原理**：
```dart
// 1. 创建Provider接收Stream
final deviceDataStreamProvider = StreamProvider<DeviceData>((ref) {
  const channel = EventChannel('device_data_stream');
  
  return channel.receiveBroadcastStream().map((data) {
    return DeviceData.fromJson(data as Map<String, dynamic>);
  });
});

// 2. 消费Stream
final dataStream = ref.watch(deviceDataStreamProvider);
dataStream.when(
  data: (deviceData) => Text('Power: ${deviceData.power}W'),
  loading: () => CircularProgressIndicator(),
  error: (err, stack) => Text('Error: $err'),
);
```

### 3.2 数据模型设计

```dart
// 设备数据快照
class DeviceData {
  final String deviceId;
  final DateTime timestamp;
  final double power;        // 功率（W）
  final double battery;      // 电量（%）
  final double voltage;      // 电压（V）
  final double current;      // 电流（A）
  final double temperature;  // 温度（℃）
  final DeviceStatus status; // 状态
  
  // 从JSON解析
  factory DeviceData.fromJson(Map<String, dynamic> json) => DeviceData(
    deviceId: json['deviceId'] as String,
    timestamp: DateTime.parse(json['timestamp'] as String),
    power: (json['power'] as num).toDouble(),
    battery: (json['battery'] as num).toDouble(),
    voltage: (json['voltage'] as num).toDouble(),
    current: (json['current'] as num).toDouble(),
    temperature: (json['temperature'] as num).toDouble(),
    status: DeviceStatus.fromString(json['status'] as String),
  );
}

enum DeviceStatus {
  charging,    // 充电中
  discharging, // 放电中
  standby,     // 待机
  error,       // 异常
}
```

## 4. Riverpod状态管理

### 4.1 Provider设计

```dart
// 1. 原始数据流（来自Native）
final deviceDataStreamProvider = StreamProvider<DeviceData>((ref) {
  const channel = EventChannel('device_data_stream');
  return channel.receiveBroadcastStream()
    .map((data) => DeviceData.fromJson(data));
});

// 2. 设备状态管理（含历史数据）
final deviceStateProvider = 
    NotifierProvider<DeviceStateNotifier, DeviceState>(
  () => DeviceStateNotifier(),
);

// 3. 图表数据（派生状态）
final chartDataProvider = Provider<List<ChartPoint>>((ref) {
  final state = ref.watch(deviceStateProvider);
  return state.history.map((data) => ChartPoint(
    x: data.timestamp.millisecondsSinceEpoch.toDouble(),
    y: data.power,
  )).toList();
});

// 4. 连接状态
final connectionStatusProvider = 
    StateProvider<ConnectionStatus>((ref) => ConnectionStatus.disconnected);
```

### 4.2 DeviceStateNotifier实现

**核心逻辑**：
```dart
class DeviceStateNotifier extends Notifier<DeviceState> {
  static const _maxHistorySize = 1000; // 最多保存1000个数据点
  
  @override
  DeviceState build() {
    // 监听Stream并更新状态
    ref.listen(deviceDataStreamProvider, (prev, next) {
      next.whenData((data) => _handleNewData(data));
    });
    
    return DeviceState.initial();
  }
  
  void _handleNewData(DeviceData data) {
    final currentState = state;
    
    // 更新当前数据
    final updatedHistory = [
      ...currentState.history,
      data,
    ];
    
    // 限制历史数据大小
    if (updatedHistory.length > _maxHistorySize) {
      updatedHistory.removeAt(0);
    }
    
    state = currentState.copyWith(
      current: data,
      history: updatedHistory,
      lastUpdateTime: DateTime.now(),
    );
  }
  
  // 清空历史数据
  void clearHistory() {
    state = state.copyWith(history: []);
  }
}

class DeviceState {
  final DeviceData? current;
  final List<DeviceData> history;
  final DateTime? lastUpdateTime;
  
  // 派生属性
  double get averagePower => 
    history.isEmpty ? 0.0 : 
    history.map((d) => d.power).reduce((a, b) => a + b) / history.length;
}
```

## 5. 图表绘制优化

### 5.1 图表库选择

**fl_chart优势**：
- ✅ 纯Dart实现，跨平台
- ✅ 高性能
- ✅ 支持实时数据
- ✅ 自定义能力强

### 5.2 性能优化策略

**问题**：高频数据更新导致卡顿

**优化方案**：

#### 1. 数据抽样
```dart
// 图表只显示最近的100个点
final chartDataProvider = Provider<List<ChartPoint>>((ref) {
  final state = ref.watch(deviceStateProvider);
  final history = state.history;
  
  // 如果数据点太多，进行抽样
  if (history.length > 100) {
    final step = history.length ~/ 100;
    return [
      for (int i = 0; i < history.length; i += step)
        _toChartPoint(history[i])
    ];
  }
  
  return history.map(_toChartPoint).toList();
});
```

#### 2. 节流更新
```dart
class ThrottledChartWidget extends ConsumerStatefulWidget {
  @override
  _State createState() => _State();
}

class _State extends ConsumerState<ThrottledChartWidget> {
  DateTime? _lastUpdateTime;
  static const _updateInterval = Duration(milliseconds: 500); // 500ms更新一次
  
  @override
  Widget build(BuildContext context) {
    // 节流：不是每次数据变化都重建
    ref.listen(deviceStateProvider, (prev, next) {
      final now = DateTime.now();
      if (_lastUpdateTime == null || 
          now.difference(_lastUpdateTime!) > _updateInterval) {
        _lastUpdateTime = now;
        setState(() {}); // 只有满足时间间隔才更新
      }
    });
    
    return LineChart(/* ... */);
  }
}
```

#### 3. 局部重建
```dart
// 只重建图表部分，其他Widget不变
Column(
  children: [
    const DeviceInfoCard(), // const，不重建
    
    // 只有这部分会更新
    Consumer(
      builder: (context, ref, child) {
        final chartData = ref.watch(chartDataProvider);
        return LineChart(chartData);
      },
    ),
    
    const DeviceControlPanel(), // const，不重建
  ],
)
```

## 6. 异常处理

### 6.1 连接断开处理

**场景**：蓝牙突然断开

**处理策略**：
```
1. iOS端检测断开
   ↓
2. 通过EventChannel发送错误事件
   eventSink?.error("DISCONNECTED", "Bluetooth disconnected", nil)
   ↓
3. Flutter端捕获错误
   deviceDataStreamProvider.when(
     error: (err, stack) => _handleDisconnect(err)
   )
   ↓
4. UI显示断连状态
   ↓
5. 可选：自动重连机制
```

### 6.2 数据异常处理

**异常数据过滤**：
```dart
void _handleNewData(DeviceData data) {
  // 数据合法性检查
  if (!_isValidData(data)) {
    print('Invalid data received: $data');
    return; // 丢弃异常数据
  }
  
  // 更新状态
  state = state.copyWith(current: data);
}

bool _isValidData(DeviceData data) {
  return data.power >= 0 && 
         data.power <= 10000 && // 最大10kW
         data.battery >= 0 && 
         data.battery <= 100 &&
         data.temperature > -40 && 
         data.temperature < 100;
}
```

## 7. UI设计

### 7.1 组件结构

```
DeviceMonitorScreen
├─ AppBar (设备名称、连接状态)
├─ DeviceStatusCard (当前数据快照)
│   ├─ 功率显示
│   ├─ 电量显示
│   ├─ 温度显示
│   └─ 状态指示器
├─ TabBar (切换图表类型)
│   ├─ 功率曲线
│   ├─ 电量曲线
│   └─ 温度曲线
└─ ChartWidget (实时图表)
    ├─ LineChart
    ├─ 时间轴
    └─ 数据点标注
```

### 7.2 关键Widget

```dart
class DeviceStatusCard extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(deviceStateProvider);
    final current = state.current;
    
    if (current == null) {
      return const Text('等待数据...');
    }
    
    return Card(
      child: GridView(
        children: [
          _DataTile(
            icon: Icons.bolt,
            label: '功率',
            value: '${current.power.toStringAsFixed(1)} W',
            color: Colors.orange,
          ),
          _DataTile(
            icon: Icons.battery_charging_full,
            label: '电量',
            value: '${current.battery.toStringAsFixed(0)}%',
            color: _getBatteryColor(current.battery),
          ),
          // ... 其他数据
        ],
      ),
    );
  }
}
```

## 8. 性能监控

### 8.1 关键指标

```dart
class PerformanceMonitor {
  int _dataPointsReceived = 0;
  int _framesRendered = 0;
  DateTime _startTime = DateTime.now();
  
  void recordDataPoint() {
    _dataPointsReceived++;
  }
  
  void recordFrameRendered() {
    _framesRendered++;
  }
  
  void printStats() {
    final duration = DateTime.now().difference(_startTime);
    final dataRate = _dataPointsReceived / duration.inSeconds;
    final fps = _framesRendered / duration.inSeconds;
    
    print('数据接收率: ${dataRate.toStringAsFixed(1)} 点/秒');
    print('帧率: ${fps.toStringAsFixed(1)} FPS');
  }
}
```

### 8.2 性能目标

```
✅ 数据接收率：1-2 点/秒（符合业务需求）
✅ UI帧率：>= 30 FPS（流畅）
✅ 内存占用：< 100MB
✅ CPU占用：< 20%
```

## 9. 总结

### 9.1 核心设计要点

```
✅ EventChannel实现Native到Flutter的数据推送
✅ StreamProvider接收实时数据流
✅ NotifierProvider管理状态和历史数据
✅ 数据抽样和节流优化图表性能
✅ 局部重建避免全局刷新
✅ 完整的异常处理机制
```

### 9.2 架构优势

```
✅ 分层清晰
  - Platform Bridge负责通信
  - Provider负责状态
  - UI负责展示

✅ 性能优化
  - 数据抽样
  - 节流更新
  - 局部重建

✅ 可扩展
  - 易于添加新的数据类型
  - 易于切换图表库
  - 易于添加数据分析功能
```

### 9.3 关键原理

**实时数据流处理**：
```
蓝牙设备 → iOS → EventChannel → StreamProvider → UI
         (Native)  (Platform)    (Riverpod)    (Flutter)
```

**性能优化核心**：
- 不是每次数据变化都重建UI
- 使用节流和抽样控制更新频率
- 只重建需要更新的部分

这就是一个完整的蓝牙设备数据可视化组件的架构设计！

