# 实战：智能小车实时追踪组件

## 1. 场景分析

### 1.1 业务场景

**移动机器人监控系统**：
- iOS通过网络/蓝牙接收小车位置数据
- 实时在地图上显示小车位置和运动轨迹
- 展示小车状态（速度、电量、任务状态等）
- 位置更新频率：100ms - 1s/次
- 支持多辆小车同时监控

### 1.2 技术挑战

```
核心挑战：
✅ 高频位置更新（10次/秒）
✅ 地图性能优化（避免卡顿）
✅ 轨迹绘制（路径平滑、历史记录）
✅ 状态同步（位置、速度、方向、电量）
✅ 多车辆管理
✅ 离线地图缓存
```

## 2. 整体架构设计

### 2.1 分层架构

```
┌──────────────────────────────────────────────────┐
│            iOS Native Layer                      │
│  ┌──────────────┐  ┌──────────────┐             │
│  │ Network/BLE  │  │Location Data │             │
│  │ Manager      │  │ Processor    │             │
│  └──────────────┘  └──────────────┘             │
└──────────────────────────────────────────────────┘
              ↓ EventChannel (实时位置流)
┌──────────────────────────────────────────────────┐
│         Platform Channel Bridge                  │
│  ┌──────────────────────────────────────┐        │
│  │ VehicleLocationBridge                │        │
│  │ - 位置数据流                          │        │
│  │ - 控制命令通道                        │        │
│  └──────────────────────────────────────┘        │
└──────────────────────────────────────────────────┘
              ↓ Stream<VehicleLocation>
┌──────────────────────────────────────────────────┐
│         Riverpod State Layer                     │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐        │
│  │ Vehicle  │ │ Track    │ │ Map      │        │
│  │ Provider │ │ Provider │ │ Provider │        │
│  └──────────┘ └──────────┘ └──────────┘        │
└──────────────────────────────────────────────────┘
              ↓ watch
┌──────────────────────────────────────────────────┐
│            UI Layer                               │
│  ┌──────────────┐  ┌──────────────┐             │
│  │ Map Widget   │  │ Vehicle Info │             │
│  │ (Google Map) │  │ Panel        │             │
│  └──────────────┘  └──────────────┘             │
└──────────────────────────────────────────────────┘
```

### 2.2 数据流设计

```
[GPS/传感器数据]
    ↓
[iOS定位处理]
    ├─ 坐标转换（WGS84 → GCJ02）
    ├─ 数据过滤（异常点剔除）
    └─ 速度计算
    ↓
[EventChannel Stream]
    ↓
[Flutter Location Bridge]
    ├─ 反序列化
    ├─ 数据验证
    └─ 分发到对应车辆
    ↓
[VehicleStateNotifier]
    ├─ 更新当前位置
    ├─ 追加轨迹点
    ├─ 计算运动参数
    └─ 触发地图更新
    ↓
[Map Widget]
    ├─ Marker位置更新
    ├─ Polyline轨迹绘制
    └─ 相机跟随
```

## 3. Platform Channel设计

### 3.1 双向通信设计

**数据通道（Native → Flutter）**：
```swift
// EventChannel: 位置数据流
let locationChannel = FlutterEventChannel(
  name: "vehicle_location_stream",
  binaryMessenger: messenger
)

class LocationStreamHandler: FlutterStreamHandler {
  func onListen(..., eventSink events: @escaping FlutterEventSink) {
    // 开始推送位置
    startLocationUpdates { location in
      events(location.toJSON())
    }
  }
}
```

**控制通道（Flutter → Native）**：
```swift
// MethodChannel: 控制命令
let controlChannel = FlutterMethodChannel(
  name: "vehicle_control",
  binaryMessenger: messenger
)

controlChannel.setMethodCallHandler { (call, result) in
  switch call.method {
  case "startTracking":
    let vehicleId = call.arguments as? String
    startTracking(vehicleId)
    result(nil)
    
  case "stopTracking":
    stopTracking()
    result(nil)
    
  case "centerOnVehicle":
    // 触发地图居中
    result(nil)
  }
}
```

### 3.2 数据模型设计

```dart
// 车辆位置数据
class VehicleLocation {
  final String vehicleId;
  final LatLng position;       // 经纬度
  final double heading;        // 方向角（0-360°）
  final double speed;          // 速度（m/s）
  final double accuracy;       // 定位精度（m）
  final DateTime timestamp;    // 时间戳
  
  // 扩展信息
  final double? battery;       // 电量
  final VehicleStatus status;  // 状态
  final String? taskId;        // 任务ID
}

enum VehicleStatus {
  idle,       // 空闲
  moving,     // 移动中
  paused,     // 暂停
  charging,   // 充电中
  error,      // 异常
}

// 轨迹数据
class VehicleTrack {
  final String vehicleId;
  final List<TrackPoint> points;
  final double totalDistance;  // 总距离（m）
  final DateTime startTime;
  final DateTime? endTime;
  
  TrackPoint get currentPosition => points.last;
  
  // 添加新位置点
  VehicleTrack addPoint(VehicleLocation location) {
    final newPoint = TrackPoint(
      position: location.position,
      timestamp: location.timestamp,
      speed: location.speed,
    );
    
    return copyWith(
      points: [...points, newPoint],
      totalDistance: totalDistance + _calculateDistance(
        points.last.position, 
        newPoint.position,
      ),
    );
  }
}
```

## 4. Riverpod状态管理

### 4.1 Provider设计

```dart
// 1. 位置数据流（来自Native）
final vehicleLocationStreamProvider = 
    StreamProvider.family<VehicleLocation, String>((ref, vehicleId) {
  const channel = EventChannel('vehicle_location_stream');
  
  return channel.receiveBroadcastStream(vehicleId)
    .map((data) => VehicleLocation.fromJson(data))
    .where((location) => location.vehicleId == vehicleId); // 过滤指定车辆
});

// 2. 车辆状态管理（单车）
final vehicleStateProvider = 
    NotifierProvider.family<VehicleStateNotifier, VehicleState, String>(
  (vehicleId) => VehicleStateNotifier(vehicleId),
);

// 3. 多车辆管理
final vehicleListProvider = 
    StateProvider<List<String>>((ref) => []);

// 4. 活跃车辆（所有在线车辆的状态）
final activeVehiclesProvider = Provider<Map<String, VehicleState>>((ref) {
  final vehicleIds = ref.watch(vehicleListProvider);
  
  return {
    for (final id in vehicleIds)
      id: ref.watch(vehicleStateProvider(id))
  };
});

// 5. 地图相机状态
final mapCameraProvider = 
    StateProvider<MapCamera>((ref) => MapCamera.initial());

// 6. 选中的车辆
final selectedVehicleProvider = 
    StateProvider<String?>((ref) => null);
```

### 4.2 VehicleStateNotifier实现

**核心逻辑**：
```dart
class VehicleStateNotifier extends FamilyNotifier<VehicleState, String> {
  static const _maxTrackPoints = 1000; // 最多保存1000个轨迹点
  static const _updateThreshold = 5.0;  // 位置变化阈值（米）
  
  @override
  VehicleState build(String vehicleId) {
    // 监听位置流
    ref.listen(
      vehicleLocationStreamProvider(vehicleId),
      (prev, next) {
        next.whenData((location) => _handleLocationUpdate(location));
      },
    );
    
    return VehicleState.initial(vehicleId);
  }
  
  void _handleLocationUpdate(VehicleLocation location) {
    final current = state;
    
    // 1. 检查位置是否显著变化
    if (!_isSignificantChange(current.currentLocation, location)) {
      // 位置变化不大，只更新时间戳
      state = current.copyWith(
        currentLocation: location,
        lastUpdateTime: DateTime.now(),
      );
      return;
    }
    
    // 2. 更新轨迹
    final updatedTrack = current.track.addPoint(location);
    
    // 3. 限制轨迹点数量
    if (updatedTrack.points.length > _maxTrackPoints) {
      updatedTrack.points.removeAt(0);
    }
    
    // 4. 更新状态
    state = current.copyWith(
      currentLocation: location,
      track: updatedTrack,
      lastUpdateTime: DateTime.now(),
    );
  }
  
  bool _isSignificantChange(
    VehicleLocation? old, 
    VehicleLocation newLoc,
  ) {
    if (old == null) return true;
    
    final distance = _calculateDistance(
      old.position, 
      newLoc.position,
    );
    
    return distance > _updateThreshold;
  }
  
  // 清空轨迹
  void clearTrack() {
    state = state.copyWith(
      track: VehicleTrack.empty(state.vehicleId),
    );
  }
}

class VehicleState {
  final String vehicleId;
  final VehicleLocation? currentLocation;
  final VehicleTrack track;
  final DateTime? lastUpdateTime;
  
  // 派生属性
  bool get isOnline => lastUpdateTime != null &&
    DateTime.now().difference(lastUpdateTime!) < Duration(seconds: 10);
    
  double get currentSpeed => currentLocation?.speed ?? 0.0;
  
  double get averageSpeed => track.points.isEmpty ? 0.0 :
    track.points.map((p) => p.speed).reduce((a, b) => a + b) / 
    track.points.length;
}
```

## 5. 地图集成

### 5.1 Google Maps集成

**Provider设计**：
```dart
// 地图控制器Provider
final mapControllerProvider = 
    StateProvider<GoogleMapController?>((ref) => null);

// 地图相机位置Provider
final mapCameraProvider = 
    NotifierProvider<MapCameraNotifier, CameraPosition>(
  () => MapCameraNotifier(),
);

class MapCameraNotifier extends Notifier<CameraPosition> {
  @override
  CameraPosition build() {
    return const CameraPosition(
      target: LatLng(0, 0),
      zoom: 15,
    );
  }
  
  // 跟随车辆
  void followVehicle(String vehicleId) {
    final vehicle = ref.read(vehicleStateProvider(vehicleId));
    final location = vehicle.currentLocation;
    
    if (location != null) {
      state = CameraPosition(
        target: location.position,
        zoom: 18,
        bearing: location.heading, // 地图旋转跟随车头方向
      );
    }
  }
  
  // 显示所有车辆
  void showAllVehicles() {
    final vehicles = ref.read(activeVehiclesProvider);
    final locations = vehicles.values
      .where((v) => v.currentLocation != null)
      .map((v) => v.currentLocation!.position)
      .toList();
      
    if (locations.isEmpty) return;
    
    // 计算边界
    final bounds = _calculateBounds(locations);
    state = CameraPosition(
      target: bounds.center,
      zoom: _calculateZoom(bounds),
    );
  }
}
```

### 5.2 Marker和Polyline管理

**动态更新策略**：
```dart
class VehicleMapWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final vehicles = ref.watch(activeVehiclesProvider);
    final cameraPosition = ref.watch(mapCameraProvider);
    
    // 生成Marker集合
    final markers = vehicles.entries.map((entry) {
      final vehicleId = entry.key;
      final state = entry.value;
      final location = state.currentLocation;
      
      if (location == null) return null;
      
      return Marker(
        markerId: MarkerId(vehicleId),
        position: location.position,
        rotation: location.heading, // 车辆方向
        icon: _getVehicleIcon(state.status),
        onTap: () => _onVehicleTapped(vehicleId, ref),
      );
    }).whereType<Marker>().toSet();
    
    // 生成轨迹线
    final polylines = vehicles.entries.map((entry) {
      final vehicleId = entry.key;
      final track = entry.value.track;
      
      return Polyline(
        polylineId: PolylineId(vehicleId),
        points: track.points.map((p) => p.position).toList(),
        color: _getTrackColor(vehicleId),
        width: 3,
      );
    }).toSet();
    
    return GoogleMap(
      initialCameraPosition: cameraPosition,
      markers: markers,
      polylines: polylines,
      onMapCreated: (controller) {
        ref.read(mapControllerProvider.notifier).state = controller;
      },
    );
  }
}
```

## 6. 性能优化

### 6.1 地图更新优化

**问题**：高频位置更新导致地图卡顿

**优化策略**：

#### 1. 节流更新
```dart
class ThrottledMapUpdater {
  DateTime? _lastUpdate;
  static const _minInterval = Duration(milliseconds: 200); // 最快200ms更新一次
  
  bool shouldUpdate() {
    final now = DateTime.now();
    if (_lastUpdate == null || 
        now.difference(_lastUpdate!) > _minInterval) {
      _lastUpdate = now;
      return true;
    }
    return false;
  }
}

// 在VehicleStateNotifier中使用
final _mapUpdater = ThrottledMapUpdater();

void _handleLocationUpdate(VehicleLocation location) {
  // 总是更新状态
  state = state.copyWith(currentLocation: location);
  
  // 但只在满足条件时触发地图重建
  if (_mapUpdater.shouldUpdate()) {
    ref.invalidate(mapMarkersProvider); // 触发Marker更新
  }
}
```

#### 2. 轨迹简化
```dart
class TrackSimplifier {
  // Douglas-Peucker算法简化轨迹
  static List<LatLng> simplify(
    List<LatLng> points, 
    double tolerance,
  ) {
    if (points.length < 3) return points;
    
    // 找到距离首尾连线最远的点
    double maxDistance = 0;
    int maxIndex = 0;
    
    for (int i = 1; i < points.length - 1; i++) {
      final distance = _perpendicularDistance(
        points[i],
        points.first,
        points.last,
      );
      
      if (distance > maxDistance) {
        maxDistance = distance;
        maxIndex = i;
      }
    }
    
    // 如果最大距离大于容差，递归简化
    if (maxDistance > tolerance) {
      final left = simplify(
        points.sublist(0, maxIndex + 1), 
        tolerance,
      );
      final right = simplify(
        points.sublist(maxIndex), 
        tolerance,
      );
      
      return [...left.sublist(0, left.length - 1), ...right];
    } else {
      return [points.first, points.last];
    }
  }
}

// 使用简化后的轨迹绘制Polyline
final simplifiedTrack = TrackSimplifier.simplify(
  track.points.map((p) => p.position).toList(),
  5.0, // 5米容差
);
```

#### 3. 分段加载
```dart
// 只加载可见区域的轨迹
final visibleTrackProvider = Provider.family<List<TrackPoint>, String>(
  (ref, vehicleId) {
    final track = ref.watch(vehicleStateProvider(vehicleId)).track;
    final bounds = ref.watch(mapVisibleBoundsProvider);
    
    // 过滤可见区域内的点
    return track.points.where((point) {
      return bounds.contains(point.position);
    }).toList();
  },
);
```

### 6.2 内存优化

**轨迹点数量控制**：
```dart
// 方案1：固定数量
static const _maxTrackPoints = 1000;

// 方案2：按时间窗口
final _timeWindow = Duration(hours: 2); // 只保留2小时内的数据

void _pruneOldPoints() {
  final now = DateTime.now();
  state = state.copyWith(
    track: state.track.copyWith(
      points: state.track.points.where((point) {
        return now.difference(point.timestamp) < _timeWindow;
      }).toList(),
    ),
  );
}

// 方案3：按距离间隔
final _minPointDistance = 10.0; // 最小10米间隔

bool _shouldAddPoint(LatLng newPoint) {
  if (state.track.points.isEmpty) return true;
  
  final lastPoint = state.track.points.last.position;
  final distance = _calculateDistance(lastPoint, newPoint);
  
  return distance >= _minPointDistance;
}
```

## 7. UI设计

### 7.1 组件结构

```
VehicleTrackingScreen
├─ Stack
│   ├─ GoogleMap（底层）
│   │   ├─ Markers（车辆位置）
│   │   └─ Polylines（轨迹）
│   │
│   ├─ Positioned: 顶部控制栏
│   │   ├─ 车辆列表选择器
│   │   ├─ 跟随开关
│   │   └─ 显示全部按钮
│   │
│   └─ Positioned: 底部信息面板
│       └─ VehicleInfoPanel
│           ├─ 当前速度
│           ├─ 电量
│           ├─ 总距离
│           └─ 运行时长
```

### 7.2 交互设计

**相机跟随模式**：
```dart
class CameraFollowManager {
  bool _isFollowing = false;
  String? _followingVehicleId;
  
  void toggleFollow(String vehicleId, WidgetRef ref) {
    if (_isFollowing && _followingVehicleId == vehicleId) {
      // 取消跟随
      _isFollowing = false;
      _followingVehicleId = null;
    } else {
      // 开启跟随
      _isFollowing = true;
      _followingVehicleId = vehicleId;
      
      // 监听位置变化，自动移动相机
      ref.listen(
        vehicleStateProvider(vehicleId),
        (prev, next) {
          if (_isFollowing) {
            _updateCamera(next.currentLocation);
          }
        },
      );
    }
  }
}
```

## 8. 多车辆管理

### 8.1 车辆分组

```dart
class VehicleGroup {
  final String groupId;
  final String name;
  final List<String> vehicleIds;
  final Color color;
}

final vehicleGroupsProvider = 
    StateProvider<List<VehicleGroup>>((ref) => []);

// 按组显示
final groupTrackProvider = Provider.family<List<VehicleState>, String>(
  (ref, groupId) {
    final group = ref.watch(vehicleGroupsProvider)
      .firstWhere((g) => g.groupId == groupId);
      
    return group.vehicleIds
      .map((id) => ref.watch(vehicleStateProvider(id)))
      .toList();
  },
);
```

### 8.2 性能考虑

```
单车辆：
- 位置更新：1次/秒
- 地图刷新：5次/秒（节流）
- 内存占用：~20MB

10辆车：
- 位置更新：10次/秒
- 地图刷新：5次/秒（共享）
- 内存占用：~50MB

策略：
✅ 共享地图控制器
✅ 批量更新Marker
✅ 统一节流机制
```

## 9. 总结

### 9.1 核心设计要点

```
✅ EventChannel推送实时位置
✅ Family Provider管理多车辆状态
✅ 节流更新避免地图卡顿
✅ 轨迹简化减少渲染压力
✅ 分段加载优化内存
✅ 相机跟随提升用户体验
```

### 9.2 架构优势

```
✅ 可扩展性
  - 易于添加新车辆
  - 易于扩展车辆属性
  - 易于切换地图SDK

✅ 性能优化
  - 多级节流机制
  - 智能简化算法
  - 内存控制策略

✅ 用户体验
  - 实时响应
  - 流畅动画
  - 丰富交互
```

### 9.3 关键技术

**实时数据流**：
```
GPS → iOS → EventChannel → StreamProvider → UI
     (定位)  (通道)        (状态)         (地图)
```

**性能优化核心**：
- 节流：控制更新频率
- 简化：减少渲染点数
- 批量：合并地图操作

**多车辆管理**：
- Family Provider实现按ID独立管理
- 共享地图控制器和更新机制
- 分组管理提升可维护性

这就是一个完整的智能小车实时追踪组件的架构设计！

